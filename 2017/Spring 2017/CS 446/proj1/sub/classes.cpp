/** CS 446 Project 1 - supporting data structures, class implementation
@file classes.cpp
@author Patrick Austin
@date 1/27/2017 */

#include "classes.h"
#include <fstream>
#include <iostream>
using namespace std;

/**

Event class constructor. If generated by the Data class constructor, private members are restricted to possible values described below.

@param targetCode A char representing one of the meta-data codes. The valid possibilities are S A P I O and M.
@param targetDescriptor A string representing one of the meta-data descriptors. The valid possibilities are end, hard drive,
keyboard, printer, monitor, run, start, allocate, block, mouse, speaker
@param targetCycles An int representing the number of cycles a meta-data event runs for. Valid possibilities are ints > 0.

*/

Event::Event( char targetCode, string targetDescriptor, int targetCycles )
	{
	code = targetCode;
	descriptor = targetDescriptor;
	cycles = targetCycles;
	}

//get function to return an event's code

char Event::getCode() const
	{
	return code;
	}

//get function to return an event's descriptor

string Event::getDescriptor() const
	{
	return descriptor;
	}

//get function to return an event's cycle number

int Event::getCycles() const
	{
	return cycles;
	}


/**

Data class constructor. Calls one helper function to conduct readin from the config file, and then a second helper function to conduct readin
from the metadata file. Both helper functions can throw an exception if there is an error with file readin and complete data cannot be generated,
so advise all creation of Data objects to be wrapped in a try block.

@param configPath The location of the config file, which will initialize the readin process including providing the location of the metadata file.

*/

Data::Data(char* configPath)
	{

	readConfigFile(configPath);

	readInputFile();

	}

/**

Data class helper function for config file readin. Opens the specified config file, reads in all required data, and closes the file. Conducts 
error checking for correct formatting of config data. Will throw an exception if an error occurs during the process.

@param targetPath The location of the config file.

*/

void Data::readConfigFile (char* targetPath)
	{

	//declare variables
	ifstream fin;
	string line(targetPath);	//initialize with config location cstring to check file extension
	char dummy;

	//if config file has invalid extension, error out

	if ( line.substr(line.find(".") + 1) != "conf" )
		{
		throw "Error: config file must have .conf extension, aborting.";
		return;
		}

	//attempt to open target config file

	fin.open(targetPath);

	if ( fin.peek() == std::ifstream::traits_type::eof() )
		{
		fin.close();
		throw "Error: config file empty, aborting.";
		return;
		}

	if ( fin.bad() )
		{
		fin.close();
		throw "Error: config file could not be opened, aborting.";
		return;		
		}

	//read through file, accepting needed values

	getline (fin,line);	//get line 1

		if ( line != "Start Simulator Configuration File" )	//error check for mis-formatted config file
			{			
			fin.close();
			throw "Error: mis-format in config file line 1, aborting.";
			return;
			}

	//lines 2-13 can be in an arbitrary order. read them in, checking that all are represented and valid

	for ( int i = 0; i < 12; i++ )
		{

		getline (fin, line, ':');	//read in the first half of the line

		if ( line == "Version/Phase" )			//read in version/phase, checking for valid value
			{
			getline (fin, line);
			versionNumber = atoi(line.c_str());
			if ( versionNumber > 4 | versionNumber < 1 )
				{
				fin.close();
				throw "Error: invalid value for version/phase, aborting.";
				return;
				}
			}

		else if ( line == "File Path" )			//read in file path, checking for valid extension
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, inputPath);
			if ( inputPath.substr(inputPath.find(".") + 1) != "mdf" )
				{
				fin.close();
				throw "Error: meta data file must have .mdf extension, aborting.";
				return;
				}
			}

		else if ( line == "Processor cycle time (msec)" )	//read in processor cycle time, checking for valid value
			{
			fin >> processorCycleTime;
			if ( processorCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for processor cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Monitor display time (msec)" )	//read in monitor display time, checking for valid value
			{
			fin >> monitorDisplayTime;
			if ( monitorDisplayTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for monitor display time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Hard drive cycle time (msec)" )	//read in hard drive cycle time, checking for valid value
			{
			fin >> hardDriveCycleTime;
			if ( hardDriveCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for hard drive cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Printer cycle time (msec)" )		//read in printer cycle time, checking for valid value
			{
			fin >> printerCycleTime;
			if ( printerCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for printer cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Keyboard cycle time (msec)" )	//read in keyboard cycle time, checking for valid value
			{
			fin >> keyboardCycleTime;
			if ( keyboardCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for keyboard cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Memory cycle time (msec)" )		//read in memory cycle time, checking for valid value
			{
			fin >> memoryCycleTime;
			if ( memoryCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for memory cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Mouse cycle time (msec)" )		//read in mouse cycle time, checking for valid value
			{
			fin >> mouseCycleTime;
			if ( mouseCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for mouse cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Speaker cycle time (msec)" )		//read in speaker cycle time, checking for valid value
			{
			fin >> speakerCycleTime;
			if ( speakerCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for speaker cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Log" )
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, line);

			if (line == "Log to Monitor")
				logValue = 0;

			else if (line == "Log to File")
				logValue = 1;

			else if (line == "Log to Both")
				logValue = 2;

			else
				{
				fin.close();
				throw "Error: invalid log location specification, aborting.";
				return;
				}
			
			} 

		else if ( line == "Log File Path" )
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, logPath);

			}

		else		//if some other string was read in, a value is missing or the file is not formatted correctly, error out
			{
			fin.close();
			throw "Error: expected config data not found in config file, aborting.";
			return;
			}

		}

	getline(fin, line);		//get line 14

		if ( line != "End Simulator Configuration File" )
			{
			fin.close();
			throw "Error: mis-format in config file line 14, aborting.";
			return;
			}

	//readin complete, close file

	fin.close();	

	}

/**

Data class helper function for metadata file readin. Opens the specified metadata file, reads in all required data, and closes the file. Conducts  
error checking for correct formatting of metadata. Will throw an exception if an error occurs with file opening/file empty/no valid events. 
Will output an error to console and terminate readin if some valid events are read in but then one is encountered with erroneous formatting.

@note If several events with valid formatting are followed by one with invalid formatting, this function will abort with a console error but not an
exception. The Data object will be created with a vector of events up to but not including the erroneous one. 
@note The function will throw an exception if no valid events have been constructed before a formatting error is encountered. Therefore a Data 
object has at least one valid event in the eventSequence vector if construction was successful.

*/


void Data::readInputFile()
	{

	//declare variables

	ifstream fin;
	string dummyString;
	char dummyChar;
	string dummyDescriptor;
	char dummyCode;
	int dummyCycles;
	bool eventsRemaining = true;

	//attempt to open target config file
	fin.open(inputPath);

	if ( fin.peek() == std::ifstream::traits_type::eof() )
		{
		fin.close();
		throw "Error: input file empty, aborting.";
		return;
		}

	if ( fin.bad() )
		{
		fin.close();
		throw "Error: input file could not be opened, aborting.";
		return;		
		}

	//read through file, adding events to the vector

	getline (fin,dummyString);	//handle line 1

	if ( dummyString != "Start Program Meta-Data Code:" )
		{			
		fin.close();
		throw "Error: mis-format in input file line 1, aborting.";
		return;
		}

	//handle unknown number of lines of unknown number of events with unknown amount of whitespace between each piece

	while (eventsRemaining == true)		//loop until last event has been added
		{

		while ( fin.peek() == ' ' )	//read past initial white space
			fin.get(dummyChar);

		fin >> dummyCode;		//first char found after white space will be the code

		if ( dummyCode != 'S' & dummyCode != 'A' & dummyCode != 'P' & dummyCode != 'I' & dummyCode != 'O' & dummyCode != 'M' )
			{
			fin.close();		//error check for valid code value
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid code in metadata file, terminating readin." << endl;
				return;
				}
			}

		while ( fin.peek() == '(' | fin.peek() == ' ' )		//read past white space and ( to find start of descriptor
			fin.get(dummyChar);

		if ( fin.peek() == ')' )
			{
			fin.close();		//error check for empty descriptor field
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: descriptor not specified in metadata file, terminating readin." << endl;
				return;
				}
			}

		while ( fin.peek() != ')' & fin.peek() != ' ' )		//read descriptor into string until space or ) is found
			{

			fin.get(dummyChar);

			dummyDescriptor += dummyChar;

			if ( dummyDescriptor == "hard" )		//special case for "hard drive" descriptor, due to space: if "hard", keep reading in
				{
				fin.get(dummyChar);
				dummyDescriptor += dummyChar;
				}

			}

		if ( dummyDescriptor != "end" & dummyDescriptor != "hard drive" & dummyDescriptor != "keyboard" & dummyDescriptor != "printer"
			& dummyDescriptor != "monitor" & dummyDescriptor != "run" & dummyDescriptor != "start" & dummyDescriptor != "allocate"
			& dummyDescriptor != "mouse" & dummyDescriptor != "speaker" & dummyDescriptor != "block" )
			{
			fin.close();		//error check for valid descriptor value
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid descriptor in metadata file, terminating readin." << endl;
				return;
				}
			}
		
		while ( fin.peek() != ')' )		//read up to )
			fin.get(dummyChar);

		fin.get(dummyChar);	//read in )

		while ( fin.peek() == ' ' )	//read past white space
			fin.get(dummyChar);

		if ( fin.peek() != '0' & fin.peek() != '1' & fin.peek() != '2' & fin.peek() != '3' & fin.peek() != '4' & fin.peek() != '5'
			& fin.peek() != '6' & fin.peek() != '7' & fin.peek() != '8' & fin.peek() != '9' & fin.peek() != '-' )
			{
			fin.close();		//error check for an integer or minus sign as next char, denoting presence of number of cycles
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: number of cycles not designated in metadata file, terminating readin." << endl;
				return;
				}
			}

		fin >> dummyCycles;	//read num cycles

		if ( dummyCycles < 0 )
			{
			fin.close();		//error check for non-negative cycle number
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid cycle value in metadata file, terminating readin." << endl;
				return;
				}
			}

		//create a new event with these values at the back of the vector of events

		eventSequence.push_back( Event(dummyCode, dummyDescriptor, dummyCycles) );

		//the final event will have a code of S and a descriptor of end. If that is this event, flip the events remaining flag
	
		if ( dummyCode == 'S' & dummyDescriptor == "end" )
			{
			eventsRemaining = false;
			}

		else //otherwise, ....
			{

			//reset dummyDescriptor string for next round of the loop

			dummyDescriptor.clear();

			//read up to the white space before the next code

			while ( fin.peek() == ' ' )	//read past initial white space
				fin.get(dummyChar);

			fin.get(dummyChar);

			}

	}

	getline (fin, dummyString);	//handle final line
	getline (fin, dummyString);
	fin.close();

	if ( dummyString != "End Program Meta-Data Code." )	//check presence of final metadata line
		{
		cout << "Error: mis-format in input file final line." << endl;
		return;
		}
		
	}

/**

Data class public output function. Depending on the log parameter specified in the config file, outputs formatted log information to
the monitor, a logfile at a location specified in the config file, or both. 

*/

void Data::output() const
	{

	//depending on log parameter, output data to specified log file or monitor or both

	//declare variables

	ofstream fout;

	//output to monitor if specified

	if ( logValue == 0 | logValue == 2 )
		{

		cout << "Configuration File Data" << endl;
		cout << "Processor = " << processorCycleTime << " ms/cycle" << endl;
		cout << "Monitor = " << monitorDisplayTime << " ms/cycle" << endl;
		cout << "Hard Drive = " << hardDriveCycleTime << " ms/cycle" << endl;
		cout << "Printer = " << printerCycleTime << " ms/cycle" << endl;
		cout << "Keyboard = " << keyboardCycleTime << " ms/cycle" << endl;
		cout << "Memory = " << memoryCycleTime << " ms/cycle" << endl;
		cout << "Mouse = " << mouseCycleTime << " ms/cycle" << endl;
		cout << "Speaker = " << speakerCycleTime << " ms/cycle" << endl;
	
		cout << "Logged to: ";

		if ( logValue == 0 )
			cout << "monitor" << endl;

		if ( logValue == 1 )
			cout << logPath << endl;

		if ( logValue == 2 )
			cout << "monitor and " << logPath << endl;

		cout << endl;

		cout << "Meta-Data Metrics" << endl;
	
		for ( int i = 0; i < eventSequence.size(); i++ )
			{

			if ( eventSequence[i].getCycles() > 0 )
				{

				cout << eventSequence[i].getCode() << "(" << eventSequence[i].getDescriptor() << ")" 
					<< eventSequence[i].getCycles() << " - ";

				if ( eventSequence[i].getDescriptor() == "hard drive" )
					cout<< eventSequence[i].getCycles() * hardDriveCycleTime;

				if ( eventSequence[i].getDescriptor() == "keyboard" )
					cout << eventSequence[i].getCycles() * keyboardCycleTime;

				if ( eventSequence[i].getDescriptor() == "printer" )
					cout << eventSequence[i].getCycles() * printerCycleTime;

				if ( eventSequence[i].getDescriptor() == "monitor" )
					cout << eventSequence[i].getCycles() * monitorDisplayTime;

				if ( eventSequence[i].getDescriptor() == "run" )
					cout << eventSequence[i].getCycles() * processorCycleTime;

				if ( eventSequence[i].getDescriptor() == "allocate" )
					cout << eventSequence[i].getCycles() * memoryCycleTime;

				if ( eventSequence[i].getDescriptor() == "block" )
					cout << eventSequence[i].getCycles() * memoryCycleTime;

				if ( eventSequence[i].getDescriptor() == "mouse" )
					cout << eventSequence[i].getCycles() * mouseCycleTime;
				
				if ( eventSequence[i].getDescriptor() == "speaker" )
					cout << eventSequence[i].getCycles() * speakerCycleTime;

				cout << " ms" << endl;

				}

			} 

		cout << endl;

		}
		

	//output to log file if specified
	
	if ( logValue == 1 | logValue == 2 )
		{

		fout.open(logPath);

		fout << "Configuration File Data" << endl;
		fout << "Processor = " << processorCycleTime << " ms/cycle" << endl;
		fout << "Monitor = " << monitorDisplayTime << " ms/cycle" << endl;
		fout << "Hard Drive = " << hardDriveCycleTime << " ms/cycle" << endl;
		fout << "Printer = " << printerCycleTime << " ms/cycle" << endl;
		fout << "Keyboard = " << keyboardCycleTime << " ms/cycle" << endl;
		fout << "Memory = " << memoryCycleTime << " ms/cycle" << endl;
		fout << "Mouse = " << mouseCycleTime << " ms/cycle" << endl;
		fout << "Speaker = " << speakerCycleTime << " ms/cycle" << endl;
	
		fout << "Logged to: ";

		if ( logValue == 0 )
			fout << "monitor" << endl;

		if ( logValue == 1 )
			fout << logPath << endl;

		if ( logValue == 2 )
			fout << "monitor and " << logPath << endl;

		fout << endl;

		fout << "Meta-Data Metrics" << endl;
	
		for ( int i = 0; i < eventSequence.size(); i++ )
			{

			if ( eventSequence[i].getCycles() > 0 )
				{

				fout << eventSequence[i].getCode() << "(" << eventSequence[i].getDescriptor() << ")" 
					<< eventSequence[i].getCycles() << " - ";

				if ( eventSequence[i].getDescriptor() == "hard drive" )
					fout<< eventSequence[i].getCycles() * hardDriveCycleTime;

				if ( eventSequence[i].getDescriptor() == "keyboard" )
					fout << eventSequence[i].getCycles() * keyboardCycleTime;

				if ( eventSequence[i].getDescriptor() == "printer" )
					fout << eventSequence[i].getCycles() * printerCycleTime;

				if ( eventSequence[i].getDescriptor() == "monitor" )
					fout << eventSequence[i].getCycles() * monitorDisplayTime;

				if ( eventSequence[i].getDescriptor() == "run" )
					fout << eventSequence[i].getCycles() * processorCycleTime;

				if ( eventSequence[i].getDescriptor() == "allocate" )
					fout << eventSequence[i].getCycles() * memoryCycleTime;

				if ( eventSequence[i].getDescriptor() == "block" )
					fout << eventSequence[i].getCycles() * memoryCycleTime;

				if ( eventSequence[i].getDescriptor() == "mouse" )
					fout << eventSequence[i].getCycles() * mouseCycleTime;
				
				if ( eventSequence[i].getDescriptor() == "speaker" )
					fout << eventSequence[i].getCycles() * speakerCycleTime;

				fout << " ms" << endl;

				}

			} 
		

		}

	}
