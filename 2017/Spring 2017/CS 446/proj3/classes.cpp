/** CS 446 Project 3 - supporting data structures, class implementation
@file classes.cpp
@author Patrick Austin
@date 3/8/2017 
@note: program tested on ECC ubuntu install, NOT on the nomachine
*/

#include "classes.h"
#include <fstream>
#include <iostream>
#include <unistd.h>
#include <chrono>
#include <iomanip>
#include <semaphore.h>
using namespace std;

/**

Event class constructor. If generated by the Data class constructor, private members are restricted to possible values described below.

@param targetCode A char representing one of the meta-data codes. The valid possibilities are S A P I O and M.
@param targetDescriptor A string representing one of the meta-data descriptors. The valid possibilities are end, hard drive,
keyboard, printer, monitor, run, start, allocate, block, mouse, speaker
@param targetCycles An int representing the number of cycles a meta-data event runs for. Valid possibilities are ints > 0.

*/

Event::Event( char targetCode, string targetDescriptor, int targetCycles )
	{
	code = targetCode;
	descriptor = targetDescriptor;
	cycles = targetCycles;
	}

//get function to return an event's code

char Event::getCode() const
	{
	return code;
	}

//get function to return an event's descriptor

string Event::getDescriptor() const
	{
	return descriptor;
	}

//get function to return an event's cycle number

int Event::getCycles() const
	{
	return cycles;
	}

//set function to set the current state of the PCB- only valid options are 0-4.
//if another value is offered, sets PCB to exit to denote error state

void ProcessControlBlock::setState (int target)
	{

	if ( target > 4 | target < 0 )
		state = 4;

	else
		state = target;

	}

//get function to return PCB's current state

int ProcessControlBlock::getState() const
	{
	return state;
	}

/**

Data class constructor. Calls one helper function to conduct readin from the config file, and then a second helper function to conduct readin
from the metadata file. Both helper functions can throw an exception if there is an error with file readin and complete data cannot be generated,
so advise all creation of Data objects to be wrapped in a try block.

@param configPath The location of the config file, which will initialize the readin process including providing the location of the metadata file.

*/

Data::Data(char* configPath)
	{

	readConfigFile(configPath);

	readInputFile();

	}

/**

Data class helper function for config file readin. Opens the specified config file, reads in all required data, and closes the file. Conducts 
error checking for correct formatting of config data. Will throw an exception if an error occurs during the process.

@param targetPath The location of the config file.

*/

void Data::readConfigFile (char* targetPath)
	{

	//declare variables
	ifstream fin;
	string line(targetPath);	//initialize with config location cstring to check file extension
	char dummy;

	//if config file has invalid extension, error out

	if ( line.substr(line.find(".") + 1) != "conf" )
		{
		throw "Error: config file must have .conf extension, aborting.";
		return;
		}

	//attempt to open target config file

	fin.open(targetPath);

	if ( fin.peek() == std::ifstream::traits_type::eof() )
		{
		fin.close();
		throw "Error: config file empty, aborting.";
		return;
		}

	if ( fin.bad() )
		{
		fin.close();
		throw "Error: config file could not be opened, aborting.";
		return;		
		}

	//read through file, accepting needed values

	getline (fin,line);	//get line 1

		if ( line != "Start Simulator Configuration File" )	//error check for mis-formatted config file
			{			
			fin.close();
			throw "Error: mis-format in config file line 1, aborting.";
			return;
			}

	//lines 2-13 can be in an arbitrary order. read them in, checking that all are represented and valid

	for ( int i = 0; i < 16; i++ )
		{

		getline (fin, line, ':');	//read in the first half of the line

		if ( line == "Version/Phase" )			//read in version/phase, checking for valid value
			{
			getline (fin, line);
			versionNumber = atoi(line.c_str());
			if ( versionNumber > 4 | versionNumber < 1 )
				{
				fin.close();
				throw "Error: invalid value for version/phase, aborting.";
				return;
				}
			}

		else if ( line == "File Path" )			//read in file path, checking for valid extension
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, inputPath);
			if ( inputPath.substr(inputPath.find(".") + 1) != "mdf" )
				{
				fin.close();
				throw "Error: meta data file must have .mdf extension, aborting.";
				return;
				}
			}

		else if ( line == "Processor cycle time (msec)" )	//read in processor cycle time, checking for valid value
			{
			fin >> processorCycleTime;
			if ( processorCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for processor cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Monitor display time (msec)" )	//read in monitor display time, checking for valid value
			{
			fin >> monitorDisplayTime;
			if ( monitorDisplayTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for monitor display time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Hard drive cycle time (msec)" )	//read in hard drive cycle time, checking for valid value
			{
			fin >> hardDriveCycleTime;
			if ( hardDriveCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for hard drive cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Printer cycle time (msec)" )		//read in printer cycle time, checking for valid value
			{
			fin >> printerCycleTime;
			if ( printerCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for printer cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Keyboard cycle time (msec)" )	//read in keyboard cycle time, checking for valid value
			{
			fin >> keyboardCycleTime;
			if ( keyboardCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for keyboard cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Memory cycle time (msec)" )		//read in memory cycle time, checking for valid value
			{
			fin >> memoryCycleTime;
			if ( memoryCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for memory cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Mouse cycle time (msec)" )		//read in mouse cycle time, checking for valid value
			{
			fin >> mouseCycleTime;
			if ( mouseCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for mouse cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Speaker cycle time (msec)" )		//read in speaker cycle time, checking for valid value
			{
			fin >> speakerCycleTime;
			if ( speakerCycleTime <= 0 )
				{
				fin.close();
				throw "Error: invalid value for speaker cycle time, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Log" )
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, line);

			if (line == "Log to Monitor")
				logValue = 0;

			else if (line == "Log to File")
				logValue = 1;

			else if (line == "Log to Both")
				logValue = 2;

			else
				{
				fin.close();
				throw "Error: invalid log location specification, aborting.";
				return;
				}
			
			} 

		else if ( line == "Log File Path" )
			{

			while ( fin.peek() == ' ' | fin.peek() == '\t' )		//skip leading white space
				fin.get(dummy);

			getline(fin, logPath);

			}

		else if ( line == "System memory (kbytes)" )
			{

			fin >> systemMemoryQuantity;

			if ( systemMemoryQuantity <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "System memory (Mbytes)" )
			{

			fin >> systemMemoryQuantity;

			systemMemoryQuantity *= 1000;

			if ( systemMemoryQuantity <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "System memory (Gbytes)" )
			{

			fin >> systemMemoryQuantity;

			systemMemoryQuantity *= 1000000;

			if ( systemMemoryQuantity <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Memory block size (kbytes)" )
			{

			fin >> systemMemoryBlockSize;

			if ( systemMemoryBlockSize <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory block size, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Memory block size (Mbytes)" )
			{

			fin >> systemMemoryBlockSize;

			systemMemoryBlockSize *= 1000;

			if ( systemMemoryBlockSize <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory block size, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Memory block size (Gbytes)" )
			{

			fin >> systemMemoryBlockSize;

			systemMemoryBlockSize *= 1000000;

			if ( systemMemoryBlockSize <= 0 )
				{
				fin.close();
				throw "Error: invalid value for system memory block size, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Printer quantity" )
			{

			fin >> printerQuantity;

			if ( printerQuantity <= 0 )
				{
				fin.close();
				throw "Error: invalid value for printer quantity, aborting.";
				return;
				}
			getline(fin, line);
			}

		else if ( line == "Hard drive quantity" )
			{

			fin >> hardDriveQuantity;

			if ( hardDriveQuantity <= 0 )
				{
				fin.close();
				throw "Error: invalid value for hard drive quantity, aborting.";
				return;
				}
			getline(fin, line);
			}


		else		//if some other string was read in, a value is missing or the file is not formatted correctly, error out
			{
	cout << line << endl;
			fin.close();
			throw "Error: expected config data not found in config file, aborting.";
			return;
			}

		}

	getline(fin, line);		//get line 14

		if ( line != "End Simulator Configuration File" )
			{
			fin.close();
			throw "Error: mis-format in config file line 14, aborting.";
			return;
			}

	if ( systemMemoryBlockSize > systemMemoryQuantity )
		{
		fin.close();
		throw "Error: invalid value for system memory block size, aborting.";
		return;
		}

	//readin complete, close file

	fin.close();	

	}

/**

Data class helper function for metadata file readin. Opens the specified metadata file, reads in all required data, and closes the file. Conducts  
error checking for correct formatting of metadata. Will throw an exception if an error occurs with file opening/file empty/no valid events. 
Will output an error to console and terminate readin if some valid events are read in but then one is encountered with erroneous formatting.

@note If several events with valid formatting are followed by one with invalid formatting, this function will abort with a console error but not an
exception. The Data object will be created with a vector of events up to but not including the erroneous one. 
@note The function will throw an exception if no valid events have been constructed before a formatting error is encountered. Therefore a Data 
object has at least one valid event in the eventSequence vector if construction was successful.

*/


void Data::readInputFile()
	{

	//declare variables

	ifstream fin;
	string dummyString;
	char dummyChar;
	string dummyDescriptor;
	char dummyCode;
	int dummyCycles;
	bool eventsRemaining = true;

	//attempt to open target config file
	fin.open(inputPath);

	if ( fin.peek() == std::ifstream::traits_type::eof() )
		{
		fin.close();
		throw "Error: input file empty, aborting.";
		return;
		}

	if ( fin.bad() )
		{
		fin.close();
		throw "Error: input file could not be opened, aborting.";
		return;		
		}

	//read through file, adding events to the vector

	getline (fin,dummyString);	//handle line 1

	if ( dummyString != "Start Program Meta-Data Code:" )
		{			
		fin.close();
		throw "Error: mis-format in input file line 1, aborting.";
		return;
		}

	//handle unknown number of lines of unknown number of events with unknown amount of whitespace between each piece

	while (eventsRemaining == true)		//loop until last event has been added
		{

		while ( fin.peek() == ' ' )	//read past initial white space
			fin.get(dummyChar);

		fin >> dummyCode;		//first char found after white space will be the code

		if ( dummyCode != 'S' & dummyCode != 'A' & dummyCode != 'P' & dummyCode != 'I' & dummyCode != 'O' & dummyCode != 'M' )
			{
			fin.close();		//error check for valid code value
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid code in metadata file, terminating readin." << endl;
				return;
				}
			}

		while ( fin.peek() == '(' | fin.peek() == ' ' )		//read past white space and ( to find start of descriptor
			fin.get(dummyChar);

		if ( fin.peek() == ')' )
			{
			fin.close();		//error check for empty descriptor field
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: descriptor not specified in metadata file, terminating readin." << endl;
				return;
				}
			}

		while ( fin.peek() != ')' & fin.peek() != ' ' )		//read descriptor into string until space or ) is found
			{

			fin.get(dummyChar);

			dummyDescriptor += dummyChar;

			if ( dummyDescriptor == "hard" )		//special case for "hard drive" descriptor, due to space: if "hard", keep reading in
				{
				fin.get(dummyChar);
				dummyDescriptor += dummyChar;
				}

			}

		if ( dummyDescriptor != "end" & dummyDescriptor != "hard drive" & dummyDescriptor != "keyboard" & dummyDescriptor != "printer"
			& dummyDescriptor != "monitor" & dummyDescriptor != "run" & dummyDescriptor != "start" & dummyDescriptor != "allocate"
			& dummyDescriptor != "mouse" & dummyDescriptor != "speaker" & dummyDescriptor != "block" )
			{
			fin.close();		//error check for valid descriptor value
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid descriptor in metadata file, terminating readin." << endl;
				return;
				}
			}
		
		while ( fin.peek() != ')' )		//read up to )
			fin.get(dummyChar);

		fin.get(dummyChar);	//read in )

		while ( fin.peek() == ' ' )	//read past white space
			fin.get(dummyChar);

		if ( fin.peek() != '0' & fin.peek() != '1' & fin.peek() != '2' & fin.peek() != '3' & fin.peek() != '4' & fin.peek() != '5'
			& fin.peek() != '6' & fin.peek() != '7' & fin.peek() != '8' & fin.peek() != '9' & fin.peek() != '-' )
			{
			fin.close();		//error check for an integer or minus sign as next char, denoting presence of number of cycles
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: number of cycles not designated in metadata file, terminating readin." << endl;
				return;
				}
			}

		fin >> dummyCycles;	//read num cycles

		if ( dummyCycles < 0 )
			{
			fin.close();		//error check for non-negative cycle number
			if ( eventSequence.empty() )
				throw "Error: no valid events in metadata file, aborting.";
			else
				{
				cout << "Error: invalid cycle value in metadata file, terminating readin." << endl;
				return;
				}
			}

		//create a new event with these values at the back of the vector of events

		eventSequence.push_back( Event(dummyCode, dummyDescriptor, dummyCycles) );

		//the final event will have a code of S and a descriptor of end. If that is this event, flip the events remaining flag
	
		if ( dummyCode == 'S' & dummyDescriptor == "end" )
			{
			eventsRemaining = false;
			}

		else //otherwise, ....
			{

			//reset dummyDescriptor string for next round of the loop

			dummyDescriptor.clear();

			//read up to the white space before the next code

			while ( fin.peek() == ' ' )	//read past initial white space
				fin.get(dummyChar);

			fin.get(dummyChar);

			}

	}

	getline (fin, dummyString);	//handle final line
	getline (fin, dummyString);
	fin.close();

	if ( dummyString != "End Program Meta-Data Code." )	//check presence of final metadata line
		{
		cout << "Error: mis-format in input file final line." << endl;
		return;
		}
		
	}

/**

global variables for use in controlling shared resource access. contains:

global pthread mutex variable for use in preventing multiple threads accessing a shared resource. locked/unlocked in runner function,
initialized in simulation functions

binary semaphores for keyboard, mouse, monitor - resources presumed to have 1 instance available

variable semaphores for keyboard and hard drive resources, which have a variable number specified in the config file

these semaphores will be initialized in the simulation functions, but are global for cross-thread access

*/

pthread_mutex_t core_lock;

sem_t mouseSemaphore;
sem_t keyboardSemaphore;
sem_t monitorSemaphore;

sem_t printerSemaphore;
sem_t hardDriveSemaphore;

/**

runner function for use with pthreads in OS simulation. waits for the number of ms specified in thread_arg to simulate
duration of IO event processing.

New in project 3: uses pthread mutex to lock at the beginning of core operation and unlock at the end to prevent 
interference or interruption

*/

void* runner(void* thread_arg)
	{

	//declare variables

	long msToRun;

	//lock mutex
	
	pthread_mutex_lock(&core_lock);

	//perform core operation (waiting)

	msToRun = (long)thread_arg;
	usleep( 1000 * msToRun );

	//unlock mutex

	pthread_mutex_unlock(&core_lock);

	//exit
	
	pthread_exit(NULL);

	}

/**

Data class simulate helper function simToMonitor. Runs the OS simulation with output to monitor using iostream. Only difference between
this and simToFile are stream type used. Timestamps are real time.

New in project 3: IO events are protected by semaphores in order to implement resource control. Memory allocate events have been overhauled
to account for a system of addressing/block allocation in the available memory specified in the v3 config file

*/

void Data::simToMonitor() const
	{

	//declare variables and initialize sim

		//create PCB object for simulation

		ProcessControlBlock stateManager;

		//initialize timer values

		std::chrono::high_resolution_clock::time_point begin = std::chrono::high_resolution_clock::now();
		std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();

		//initialize pthreads

		pthread_t threads[1];

		//set IO precision for timer output				

		cout.precision(6);

		//temp vars for simulation operations

		long msToRun;
		unsigned int currentBlock = 0;
		unsigned int currentBlockTemp;
		int currentHardDrive = 0;
		int currentHardDriveTemp;
		int currentPrinter = 0;
		int currentPrinterTemp;
		int semaphoreVal;

		//declare and initialize open semaphores for IO resources

			//mouse, keyboard, monitor are all assumed to have 1 resource available and need binary semaphores

			sem_init (&mouseSemaphore, 0, 1);
			sem_init (&keyboardSemaphore, 0, 1);
			sem_init (&monitorSemaphore, 0, 1);

			//hard drive and printer have semaphores that vary with the number of available units specified in the log file

			sem_init(&hardDriveSemaphore, 0, hardDriveQuantity);
			sem_init(&printerSemaphore, 0, printerQuantity);

		//initialize pthread semaphore

		pthread_mutex_init(&core_lock, NULL);

		//take now as the initial time of simulation

		begin = std::chrono::high_resolution_clock::now();

	//simulate each event from the eventSequence vector based on its code and descriptor

	for ( int i = 0; i < eventSequence.size(); i++ )
		{

		//handle S code events

		if ( eventSequence[i].getCode() == 'S' && eventSequence[i].getDescriptor() == "start" )
			{

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Simulator program starting" << endl; 

			stateManager.setState(0); //initialize PCB with start state

			}

		else if ( eventSequence[i].getCode() == 'S' && eventSequence[i].getDescriptor() == "end" )
			{

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0  << 
				" - Simulator program ending" << endl; 

			stateManager.setState(4); //set PCB to exit state

			}

		//handle A code events

		else if ( eventSequence[i].getCode() == 'A' && eventSequence[i].getDescriptor() == "start" )
			{

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: preparing process 1" << endl; 

			stateManager.setState(1);	//set PCB to ready

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: starting process 1" << endl;

			}

		else if ( eventSequence[i].getCode() == 'A' && eventSequence[i].getDescriptor() == "end" )
			{

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: removing process 1" << endl; 

			}


		//handle P code events 

		else if ( eventSequence[i].getCode() == 'P' )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Process 1: start processing action" << endl;

			usleep( 1000 * eventSequence[i].getCycles() * processorCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Process 1: end processing action" << endl;

			}

		//handle I code events

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "hard drive" )
			{

			//wait until a hard drive resource is unlocked

			stateManager.setState(3);

			sem_wait(&hardDriveSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentHardDriveTemp = currentHardDrive;
				currentHardDrive = ( currentHardDrive + 1 ) % hardDriveQuantity;

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
						<< " - Process 1: start hard drive input on HDD " << currentHardDriveTemp << endl;

				msToRun = eventSequence[i].getCycles() * hardDriveCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				stateManager.setState(1);		//set PCB to ready

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
						<< " - Process 1: end hard drive input" << endl;

			//done with a hard drive resource, unlock the semaphore

			sem_post(&hardDriveSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "keyboard" )
			{

			//wait until keyboard resource is unlocked

			stateManager.setState(3);

			sem_wait(&keyboardSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start keyboard input" << endl;

				msToRun = eventSequence[i].getCycles() * keyboardCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				stateManager.setState(1);		//set PCB to ready

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end keyboard input" << endl;

			//done with keyboard resource, unlock the semaphore

			sem_post(&keyboardSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "mouse" )
			{

			//wait until mouse resource is unlocked

			stateManager.setState(3);

			sem_wait(&mouseSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start mouse input" << endl;

				msToRun = eventSequence[i].getCycles() * mouseCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end mouse input" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with mouse resource, unlock the semaphore

			sem_post(&mouseSemaphore);

			}

		//handle O code events

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "hard drive" )
			{

			//wait until a hard drive resource is unlocked

			stateManager.setState(3);

			sem_wait(&hardDriveSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentHardDriveTemp = currentHardDrive;
				currentHardDrive = ( currentHardDrive + 1 ) % hardDriveQuantity;

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0
					<< " - Process 1: start hard drive output on HDD " << currentHardDriveTemp << endl;

				msToRun = eventSequence[i].getCycles() * hardDriveCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end hard drive output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with a hard drive resource, unlock the semaphore

			sem_post(&hardDriveSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "monitor" )
			{

			//wait until monitor resource is unlocked

			stateManager.setState(3);

			sem_wait(&monitorSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start monitor output" << endl;

				msToRun = eventSequence[i].getCycles() * monitorDisplayTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end monitor output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with monitor resource, unlock the semaphore

			sem_post(&monitorSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "printer" )
			{

			//wait until a printer resource is unlocked

			stateManager.setState(3);

			sem_wait(&printerSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentPrinterTemp = currentPrinter;
				currentPrinter = ( currentPrinter + 1 ) % printerQuantity;

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
					" - Process 1: start printer output on PRNTR " << currentPrinterTemp << endl;

				msToRun = eventSequence[i].getCycles() * printerCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end printer output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with a printer resource, unlock semaphore

			sem_post(&printerSemaphore);

			}
		

		//handle M code events

		else if ( eventSequence[i].getCode() == 'M' && eventSequence[i].getDescriptor() == "allocate" )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: allocating memory" << endl;

			currentBlockTemp = currentBlock;
			currentBlock = simMemory(currentBlock);

			usleep( 1000 * eventSequence[i].getCycles() * memoryCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: memory allocated at 0x" << hex << setfill('0') << setw(8) << right << currentBlockTemp << dec << endl;

			}

		else if ( eventSequence[i].getCode() == 'M' && eventSequence[i].getDescriptor() == "block" )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: start memory blocking" << endl;

			usleep( 1000 * eventSequence[i].getCycles() * memoryCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			cout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: end memory blocking" << endl;

			}

		}

	}

/**

Data class simulate helper function simToFile. Runs the OS simulation with output to file using fstream. Only difference between
this and simToFile are stream type used. Timestamps are real time.

New in project 3: IO events are protected by semaphores in order to implement resource control. Memory allocate events have been overhauled
to account for a system of addressing/block allocation in the available memory specified in the v3 config file

*/

void Data::simToFile() const
	{

	//print console message

	cout << "Beginning simulation to file located at " << logPath << endl;

	//declare variables and initialize sim

		//ofstream object

		ofstream fout;

		//create PCB object for simulation

		ProcessControlBlock stateManager;

		//initialize timer values

		std::chrono::high_resolution_clock::time_point begin = std::chrono::high_resolution_clock::now();
		std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();

		//initialize pthreads

		pthread_t threads[1];

		//set IO precision for timer output				

		fout.precision(6);

		//temp vars for simulation operations

		long msToRun;
		unsigned int currentBlock = 0;
		unsigned int currentBlockTemp;
		int currentHardDrive = 0;
		int currentHardDriveTemp;
		int currentPrinter = 0;
		int currentPrinterTemp;
		int semaphoreVal;

		//declare and initialize open semaphores for IO resources

			//mouse, keyboard, monitor are all assumed to have 1 resource available and need binary semaphores

			sem_t mouseSemaphore;
			sem_init (&mouseSemaphore, 0, 1);
			sem_t keyboardSemaphore;
			sem_init (&keyboardSemaphore, 0, 1);
			sem_t monitorSemaphore;
			sem_init (&monitorSemaphore, 0, 1);

			//hard drive and printer have semaphores that vary with the number of available units specified in the log file

			sem_t hardDriveSemaphore;
			sem_init(&hardDriveSemaphore, 0, hardDriveQuantity);
			sem_t printerSemaphore;
			sem_init(&printerSemaphore, 0, printerQuantity);

		//initialize pthread semaphore

		pthread_mutex_init(&core_lock, NULL);

		//open file

		fout.open(logPath);

		//take now as the initial time of simulation

		begin = std::chrono::high_resolution_clock::now();

	//simulate each event from the eventSequence vector based on its code and descriptor

	for ( int i = 0; i < eventSequence.size(); i++ )
		{

		//handle S code events

		if ( eventSequence[i].getCode() == 'S' && eventSequence[i].getDescriptor() == "start" )
			{

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Simulator program starting" << endl; 

			stateManager.setState(0); //initialize PCB with start state

			}

		else if ( eventSequence[i].getCode() == 'S' && eventSequence[i].getDescriptor() == "end" )
			{

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0  << 
				" - Simulator program ending" << endl; 

			stateManager.setState(4); //set PCB to exit state

			}

		//handle A code events

		else if ( eventSequence[i].getCode() == 'A' && eventSequence[i].getDescriptor() == "start" )
			{

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: preparing process 1" << endl; 

			stateManager.setState(1);	//set PCB to ready

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: starting process 1" << endl;

			}

		else if ( eventSequence[i].getCode() == 'A' && eventSequence[i].getDescriptor() == "end" )
			{

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - OS: removing process 1" << endl; 

			}


		//handle P code events 

		else if ( eventSequence[i].getCode() == 'P' )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Process 1: start processing action" << endl;

			usleep( 1000 * eventSequence[i].getCycles() * processorCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
				" - Process 1: end processing action" << endl;

			}

		//handle I code events

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "hard drive" )
			{

			//wait until a hard drive resource is unlocked

			stateManager.setState(3);

			sem_wait(&hardDriveSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentHardDriveTemp = currentHardDrive;
				currentHardDrive = ( currentHardDrive + 1 ) % hardDriveQuantity;

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
						<< " - Process 1: start hard drive input on HDD " << currentHardDriveTemp << endl;

				msToRun = eventSequence[i].getCycles() * hardDriveCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				stateManager.setState(1);		//set PCB to ready

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
						<< " - Process 1: end hard drive input" << endl;

			//done with a hard drive resource, unlock the semaphore

			sem_post(&hardDriveSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "keyboard" )
			{

			//wait until keyboard resource is unlocked

			stateManager.setState(3);

			sem_wait(&keyboardSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start keyboard input" << endl;

				msToRun = eventSequence[i].getCycles() * keyboardCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				stateManager.setState(1);		//set PCB to ready

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end keyboard input" << endl;

			//done with keyboard resource, unlock the semaphore

			sem_post(&keyboardSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'I' && eventSequence[i].getDescriptor() == "mouse" )
			{

			//wait until mouse resource is unlocked

			stateManager.setState(3);

			sem_wait(&mouseSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start mouse input" << endl;

				msToRun = eventSequence[i].getCycles() * mouseCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end mouse input" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with mouse resource, unlock the semaphore

			sem_post(&mouseSemaphore);

			}

		//handle O code events

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "hard drive" )
			{

			//wait until a hard drive resource is unlocked

			stateManager.setState(3);

			sem_wait(&hardDriveSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentHardDriveTemp = currentHardDrive;
				currentHardDrive = ( currentHardDrive + 1 ) % hardDriveQuantity;

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0
					<< " - Process 1: start hard drive output on HDD " << currentHardDriveTemp << endl;

				msToRun = eventSequence[i].getCycles() * hardDriveCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end hard drive output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with a hard drive resource, unlock the semaphore

			sem_post(&hardDriveSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "monitor" )
			{

			//wait until monitor resource is unlocked

			stateManager.setState(3);

			sem_wait(&monitorSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: start monitor output" << endl;

				msToRun = eventSequence[i].getCycles() * monitorDisplayTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end monitor output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with monitor resource, unlock the semaphore

			sem_post(&monitorSemaphore);

			}

		else if ( eventSequence[i].getCode() == 'O' && eventSequence[i].getDescriptor() == "printer" )
			{

			//wait until a printer resource is unlocked

			stateManager.setState(3);

			sem_wait(&printerSemaphore);

			//got past lock- perform simulation

				stateManager.setState(2);

				currentPrinterTemp = currentPrinter;
				currentPrinter = ( currentPrinter + 1 ) % printerQuantity;

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 << 
					" - Process 1: start printer output on PRNTR " << currentPrinterTemp << endl;

				msToRun = eventSequence[i].getCycles() * printerCycleTime;

				pthread_create( &threads[0], NULL, runner, (void*)msToRun ); //create thread which will "run" this event

				stateManager.setState(3); 		//set PCB to waiting until thread complete

				pthread_join( threads[0], NULL ); 	//wait until thread complete

				end = std::chrono::high_resolution_clock::now();

				fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
					<< " - Process 1: end printer output" << endl;

				stateManager.setState(1);		//set PCB to ready

			//done with a printer resource, unlock semaphore

			sem_post(&printerSemaphore);

			}
		

		//handle M code events

		else if ( eventSequence[i].getCode() == 'M' && eventSequence[i].getDescriptor() == "allocate" )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: allocating memory" << endl;

			currentBlockTemp = currentBlock;
			currentBlock = simMemory(currentBlock);

			usleep( 1000 * eventSequence[i].getCycles() * memoryCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: memory allocated at 0x" << hex << setfill('0') << setw(8) << right << currentBlockTemp << dec << endl;

			}

		else if ( eventSequence[i].getCode() == 'M' && eventSequence[i].getDescriptor() == "block" )
			{

			stateManager.setState(2);	//set PCB to running

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: start memory blocking" << endl;

			usleep( 1000 * eventSequence[i].getCycles() * memoryCycleTime); //wait for operation to complete

			end = std::chrono::high_resolution_clock::now();

			fout << fixed << (std::chrono::duration_cast<std::chrono::microseconds>(end-begin).count()) / 1000000.0 
				<< " - Process 1: end memory blocking" << endl;

			}

		}

	fout.close();	

	//print console message indicating sim complete

	cout << "Simulation complete, logged to file at " << logPath << endl;

	}

/**

Data class simulate helper function simMemory as specified in prompt. Increments passed int by one block size to denote current block 
being allocated- rolls back to zero if memory is allocated over the maximum system quantity specified.

*/

unsigned int Data::simMemory(unsigned int currentBlock) const
	{

	return ( currentBlock + systemMemoryBlockSize ) % systemMemoryQuantity;

	}

/**

Data class public simulate function. Depending on the log parameter specified in the config file, runs and outputs log of OS simulation in 
the monitor, a logfile at a location specified in the config file, or both.

*/

void Data::simulate() const
	{

	//depending on log parameter, output data to specified log file or monitor or both

	if ( logValue == 0 | logValue == 2 )
		simToMonitor();

	if ( logValue == 1 | logValue == 2 )
		simToFile();

	}
